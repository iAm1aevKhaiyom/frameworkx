# Inputs

Inputs are pretty much similar to [models](models.md), but conceptually different.
Input is a type / interface / class declaration for the *user input*.
It's the same model, but for a user input.

Inputs used in GraphQL query / mutation / subscription *arguments*.


Model is a type / interface / class declaration for application domain objects.
Models are used in GraphQL and REST declarations as return types.

* [Define an Input](#define-an-input)
* [Property types](#property-types)
* [Input registration](#input-registration)
* [Inline inputs](#inline-inputs)
* [Documentation](#documentation)
* [Best practices](#best-practices)

## Define an Input

Inputs can be defined as `type`, `interface` or `class`.

Type example:

```typescript
type PostCreateInput = {
  title: string
  text: string
}
```

Interface example:

```typescript
interface PostCreateInput {
  title: string
  text: string
}
```

Class example:

```typescript
class PostCreateInput {
  title!: string
  text!: string
}
```

In GraphQL this declaration is the same as:

```graphql
input Post {
  title: String!
  text: String!
}
```

## Property types

### Primitive types

There are 3 primitive TypeScript types you can use
for your input properties:

* `boolean` is mapped to GraphQL's `Boolean`
* `number` is mapped to GraphQL's `Int`
* `string` is mapped to GraphQL's `String`

### Default scalars

There are 5 default scalars that you can use for your input properties:

* `Float` is mapped to GraphQL's `Float`
* `BigInt` is mapped to GraphQL's `String`
* `Date` is mapped to GraphQL's `String`
* `Time` is mapped to GraphQL's `String`
* `DateTime` is mapped to GraphQL's `String`

### Arrays

It's possible to create an array from any property as simple as defining it as an array type:

```typescript
type PostCreateInput = {
  categories: CategoryCreateInput[]
}
```


### Nullable types

If you want to mark a type as GraphQL's `nullable` you just define 
a property type any of these ways:

```typescript
type PostCreateInput = {
  property1: User | null
  property2: number | undefined
  property3: string | null | undefined
  property4?: Date
}
```

## Input registration

All inputs you've defined should be registered in the [application declaration](application-declaration.md):

```typescript
import { createApp } from "@microframework/core"
import { PostCreateInput } from "./input/PostCreateInput"

export const App = createApp<{
  // ...
  inputs: {
    PostCreateInput: PostCreateInput
  }
  // ...
}>()
```

## Inline inputs

In most cases you would define an input as a separate type definition, 
but sometimes you may want to define it *inline*:

```typescript
import { createApp } from "@microframework/core"

export const App = createApp<{
  // ...
  input: {
    PostCreateInput: {
      id: number
      title: string
      text: string
    }
  }
  // ...
}>()
```

However, you are limited in how you can use such type in your code.
What does make sense more is to inline nested inputs:


```typescript
export type PostCreateInput = {
  title: string
  text: string
  categories: {
    name: string
  }[]
}
```
```typescript
import { createApp } from "@microframework/core"
import { PostCreateInput } from "./input/PostCreateInput"

export const App = createApp<{
  // ...
  inputs: {
    PostCreateInput: PostCreateInput
  }
  // ...
}>()
```

From this example a new GraphQL type called `PostCreateInputCategoriesInput` 
will be generated by a framework. 

You can also define an input directly in the query / mutation / subscription declaration:

```typescript
export const App = createApp<{
  mutations: {
    postSave(args: { post: { text: string, title: string }}): Post
  }
}>()
```

## Documentation

Microframework will automatically pickup a JSDoc comments from your code
and put them into the GraphQL schema.

```typescript
/**
 * Input used to create a new Post.
 */
export type PostCreateInput = {

  /**
   * Post title.
   */
  title: string

  /**
   * Post content.
   */
  text: string
}
```

You'll be able to see these descriptions in the GraphiQL / Playground,
in the documentation section.

It's also possible to use a `@deprecated` annotation to mark properties as *deprecated*.

```typescript
/**
 * Input used to create a new Post.
 */
export type PostCreateInput = {
  /**
   * Post title.
   */
  title: string

  /**
   * Post content.
   *
   * @deprecated Don't use it anymore.
   */
  text: string
}
```

## Best practices

### What is the best way to declare an input?  

It's not recommended to use `class` for input declaration, 
since the framework doesn't instantiate class instances 
it might confuse developers. 

It's recommended to use a `type` since it's an `inteface` on steroids - 
it allows to composite a complex types. 
`type` also used to declare modes for unions and enum types, 
thus if you use `type` everywhere - you will have a more consistent code.

### What is the best practice for inline inputs?

Don't overuse them. Use them when your input is super simple and
declaring a separate type for it seems redundant.
If inline input size increases consider extracting it into a separate `type` definition. 